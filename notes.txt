control flow:
  game starts:
    - welcome player
    - create board
    - explain move structure
    - beginplay:
      - set up to player, round += 1
      - ask player which piece to move
        - varify piece is theirs, ask again if not
      - ask where to move piece
        - varify validity, ask again if not
      - move piece
        - change board
        - create move dictionary
        - check result of move
        - update library
      - set up to computer, round += 1
      - select move
        - generate possible moves
        - check library for result of each move
        - create 'options' list of non loss moves
        - randomly pick move
      - move piece (see above)
      - loop to beginning
      
      - if at any point the result generates win or loss, end game.
      - display winner
      
      - save library


# end game conditions:
  # i moved and caused other player to not be able to move = i win
  # i reached row 3 before my opponent = i win
  # player has no more pieces = i win
  # player moved and caused me to not be able to move = player wins
  # player reached row 1 before i did = player wins
  # i have no more pieces = player wins

# at any state in the game:
  # computer needs to know where its pieces are and where player pieces are; board
  # computer needs to know possible moves (check-possible_moves())
  # computer needs to know if move resulted in loss, win, or continued state

# possible move conditions:
  # if pawn 'in front' && no pawn 'to diag' stuck
  # if row + 1 != pawn and is in board move able
  # if Row + 1 && col +- 1 === pawn and on board move able.

# learn from mistakes:
  # keep a 'library' of losing moves.
  # if a move results in a loss, add to library.

# choosing move:
  # if no library:
    # generate all moves possible.
    # choose at random.
  # if library:
    # generate all possible moves
    # compare future game state to list of lost games.
    # if future state is in library, choose again.

on every move:
  create 'library' entry as follows:
    library = {round_1:[round], round_2:[round], ...} 
    --- access: library
  
      round = [{board_config_1}, {board_config_2}, ...]
      --- access: _upper_[f"round_{rndnum}"] 
  
        board_config = { 
        ---access: _upper_[index]
  
          board: [[c, c, c], [c, c, c], [c, c, c]], 
          ---access: _upper_['board']
  
          moves: [{move}, {move}, ...] 
          ---access: _upper_['move']
  
            move = { 
            ---access: _upper_[index]
  
                piece: "C" || "P", 
                ---access: _upper_['piece']
  
                from: [row, col] 
                ---access: _upper_['from']
  
                to: [row, col] 
                ---access: _upper_['to']
  
                result: "win" || "loss" || "no-change" 
              ---access: _upper_['result']
          } 
        }

# todo
  - code refactor and useage of classes.